// src/index.ts
import path from 'path';
import fs from 'fs';
import { generateModelFunctions } from './generator';
import { exit } from 'process';

// Define paths
const MODELS_PATH = path.join(__dirname, '../generated/typegraphql-prisma/models');
const INPUTS_PATH = path.join(__dirname, '../generated/typegraphql-prisma/resolvers/inputs');
const FUNCTIONS_OUTPUT_PATH = path.join(__dirname, '../');

// Ensure the output directory exists
if (!fs.existsSync(FUNCTIONS_OUTPUT_PATH)) {
  fs.mkdirSync(FUNCTIONS_OUTPUT_PATH, { recursive: true });
}

// Delete all files within the output directory (excluding the server.ts and utils.ts files, and ignore directories)
const files = fs.readdirSync(FUNCTIONS_OUTPUT_PATH);
for (const file of files) {
  if (file !== 'server.ts' && file !== 'utils.ts' && file !== 'client.ts' && file !== 'apollo-client.client.ts' && file !== 'apollo-client.server.ts' && file !== 'prismaClient.ts' && file !== 'getToken.ts') {
    const filePath = path.join(FUNCTIONS_OUTPUT_PATH, file);
    const stat = fs.statSync(filePath as fs.PathLike);
    if (stat.isFile()) {
      fs.unlinkSync(filePath);
    }
  }
}

// Initialize index file content
let indexContent = `// This file is auto-generated by modules/index.d.ts
// CRITICAL: Import reflect-metadata FIRST before any TypeGraphQL code
// This polyfill must be loaded before any decorators are evaluated
import "reflect-metadata";

export type * as types from './generated/typegraphql-prisma/models/index.d.ts';
export * as enums from './generated/typegraphql-prisma/enums/index';
export * from './generated/typeStrings/index';

// Export custom resolvers
export * from './resolvers/custom/index';

// Re-export Apollo Client functions from client.ts
export {
  getApolloClient,
  getApolloModules,
  configureConnectionPool,
  client
} from './client';

 export type {
  ApolloClientType,
  InMemoryCacheType,
  HttpLinkType,
  NormalizedCacheObject,
} from './client';

`;

// Initialize arrays for import and export statements
const importStatements: string[] = [];
const exportStatements: string[] = [];

// Retrieve all model files
let modelFiles: string[] = [];
try {
  // Check if the models directory exists
  if (fs.existsSync(MODELS_PATH)) {
    modelFiles = fs
      .readdirSync(MODELS_PATH)
      .filter((file) => file.endsWith('.ts') && file !== 'index.ts');
  } else {
    // If models directory doesn't exist, use previously generated files
    console.warn(`Models directory at ${MODELS_PATH} does not exist.`);
    console.warn('Using existing generated files or trying alternative approach.');
    
    // Try looking for model references in the Prisma schema
    const schemaPath = path.join(__dirname, '../../prisma/schema.prisma');
    if (fs.existsSync(schemaPath)) {
      const schemaContent = fs.readFileSync(schemaPath, 'utf8');
      const modelMatches = schemaContent.match(/model\s+(\w+)\s+{/g);
      if (modelMatches) {
        modelFiles = modelMatches
          .map(match => match.replace(/model\s+(\w+)\s+{/, '$1.ts'))
          .filter(Boolean);
      }
    }
  }
} catch (error) {
  console.error(`Error accessing model information:`, error);
}

// If we still don't have model files, try an alternative approach
if (modelFiles.length === 0) {
  // Look at the files in the output directory that might be model files
  try {
    const existingFiles = fs.readdirSync(FUNCTIONS_OUTPUT_PATH)
      .filter(file => 
        file.endsWith('.ts') && 
        !['index.ts', 'server.ts', 'utils.ts', 'client.ts', 'apollo-client.client.ts', 
         'apollo-client.server.ts', 'prismaClient.ts', 'getToken.ts'].includes(file)
      );
    
    if (existingFiles.length > 0) {
      modelFiles = existingFiles;
      console.warn(`Using ${existingFiles.length} existing model files from the output directory.`);
    } else {
      console.error('No model files found or extractable from schema.');
      // Don't exit, just continue with an empty set
    }
  } catch (error) {
    console.error(`Error reading output directory:`, error);
  }
}

// Iterate over the models and generate functions
modelFiles.forEach((file) => {
  const modelName = path.basename(file, '.ts');
  const capitalModelName = modelName.charAt(0).toUpperCase() + modelName.slice(1);

  const modelFunctions = generateModelFunctions(capitalModelName, MODELS_PATH, INPUTS_PATH, FUNCTIONS_OUTPUT_PATH);

  if (modelFunctions === null) {
    // Skip models that couldn't generate functions
    return;
  }

  // Add import and export statements
  importStatements.push(`import { ${modelName} } from './${modelName}';`);
  exportStatements.push(`  ${modelName[0].toLowerCase()}${modelName.slice(1)}: ${modelName},`);
});

// Append import statements to indexContent
indexContent += `
${importStatements.join('\n')}

const adaptic = {
${exportStatements.join('\n')}
};

export default adaptic;
`;

// Write the index.ts file
const indexFilePath = path.join(FUNCTIONS_OUTPUT_PATH, 'index.ts');
try {
  fs.writeFileSync(indexFilePath, indexContent, 'utf-8');
} catch (error) {
  console.error('Failed to write index.ts:', error);
}

console.log('Function generation completed successfully.');
