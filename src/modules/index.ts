// src/index.ts
import path from 'path';
import fs from 'fs';
import { generateModelFunctions } from './generator';
import { exit } from 'process';
import { logger } from '../utils/logger';

// Define paths
const MODELS_PATH = path.join(
  __dirname,
  '../generated/typegraphql-prisma/models'
);
const INPUTS_PATH = path.join(
  __dirname,
  '../generated/typegraphql-prisma/resolvers/inputs'
);
const FUNCTIONS_OUTPUT_PATH = path.join(__dirname, '../');

// Ensure the output directory exists
if (!fs.existsSync(FUNCTIONS_OUTPUT_PATH)) {
  fs.mkdirSync(FUNCTIONS_OUTPUT_PATH, { recursive: true });
}

// Delete all files within the output directory (excluding the server.ts and utils.ts files, and ignore directories)
const files = fs.readdirSync(FUNCTIONS_OUTPUT_PATH);
for (const file of files) {
  if (
    file !== 'server.ts' &&
    file !== 'utils.ts' &&
    file !== 'client.ts' &&
    file !== 'apollo-client.client.ts' &&
    file !== 'apollo-client.server.ts' &&
    file !== 'prismaClient.ts' &&
    file !== 'getToken.ts' &&
    file !== 'health.ts'
  ) {
    const filePath = path.join(FUNCTIONS_OUTPUT_PATH, file);
    const stat = fs.statSync(filePath as fs.PathLike);
    if (stat.isFile()) {
      fs.unlinkSync(filePath);
    }
  }
}

// Initialize index file content
let indexContent = `// This file is auto-generated by modules/index.d.ts
// CRITICAL: Import reflect-metadata FIRST before any TypeGraphQL code
// This polyfill must be loaded before any decorators are evaluated
import "reflect-metadata";

export type * as types from './generated/typegraphql-prisma/models/index.d.ts';
export * as enums from './generated/typegraphql-prisma/enums/index';
export * from './generated/typeStrings/index';

// Export custom resolvers
export * from './resolvers/custom/index';

// Re-export Apollo Client functions from client.ts
export {
  getApolloClient,
  getApolloModules,
  configureConnectionPool,
  setTokenProvider,
  client
} from './client';

export type {
  ApolloClientType,
  InMemoryCacheType,
  HttpLinkType,
  NormalizedCacheObject,
  TokenProvider,
} from './client';

`;

// Initialize arrays for import and export statements
const importStatements: string[] = [];
const exportStatements: string[] = [];

// Retrieve all model files
let modelFiles: string[] = [];
try {
  // Check if the models directory exists
  if (fs.existsSync(MODELS_PATH)) {
    modelFiles = fs
      .readdirSync(MODELS_PATH)
      .filter((file) => file.endsWith('.ts') && file !== 'index.ts');
  } else {
    // If models directory doesn't exist, use previously generated files
    logger.warn(`Models directory at ${MODELS_PATH} does not exist.`);
    logger.warn(
      'Using existing generated files or trying alternative approach.'
    );

    // Try looking for model references in the Prisma schema
    const schemaPath = path.join(__dirname, '../../prisma/schema.prisma');
    if (fs.existsSync(schemaPath)) {
      const schemaContent = fs.readFileSync(schemaPath, 'utf8');
      const modelMatches = schemaContent.match(/model\s+(\w+)\s+{/g);
      if (modelMatches) {
        modelFiles = modelMatches
          .map((match) => match.replace(/model\s+(\w+)\s+{/, '$1.ts'))
          .filter(Boolean);
      }
    }
  }
} catch (error) {
  logger.error('Error accessing model information', { error: String(error) });
}

// If we still don't have model files, try an alternative approach
if (modelFiles.length === 0) {
  // Look at the files in the output directory that might be model files
  try {
    const existingFiles = fs
      .readdirSync(FUNCTIONS_OUTPUT_PATH)
      .filter(
        (file) =>
          file.endsWith('.ts') &&
          ![
            'index.ts',
            'server.ts',
            'utils.ts',
            'client.ts',
            'apollo-client.client.ts',
            'apollo-client.server.ts',
            'prismaClient.ts',
            'getToken.ts',
          ].includes(file)
      );

    if (existingFiles.length > 0) {
      modelFiles = existingFiles;
      logger.warn(
        `Using ${existingFiles.length} existing model files from the output directory.`
      );
    } else {
      logger.error('No model files found or extractable from schema.');
      // Don't exit, just continue with an empty set
    }
  } catch (error) {
    logger.error('Error reading output directory', { error: String(error) });
  }
}

// Iterate over the models and generate functions
modelFiles.forEach((file) => {
  const modelName = path.basename(file, '.ts');
  const capitalModelName =
    modelName.charAt(0).toUpperCase() + modelName.slice(1);

  const modelFunctions = generateModelFunctions(
    capitalModelName,
    MODELS_PATH,
    INPUTS_PATH,
    FUNCTIONS_OUTPUT_PATH
  );

  if (modelFunctions === null) {
    // Skip models that couldn't generate functions
    return;
  }

  // Add import and export statements
  importStatements.push(`import { ${modelName} } from './${modelName}';`);
  exportStatements.push(
    `  ${modelName[0].toLowerCase()}${modelName.slice(1)}: ${modelName},`
  );
});

// Append import statements to indexContent
indexContent += `
${importStatements.join('\n')}

const adaptic = {
${exportStatements.join('\n')}
};

export default adaptic;
`;

// Write the index.ts file
const indexFilePath = path.join(FUNCTIONS_OUTPUT_PATH, 'index.ts');
try {
  fs.writeFileSync(indexFilePath, indexContent, 'utf-8');
} catch (error) {
  logger.error('Failed to write index.ts', { error: String(error) });
}

logger.info('Function generation completed successfully.');
